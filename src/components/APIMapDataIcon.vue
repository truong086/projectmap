<template>
  <div>
    <h3>T√¨m ki·∫øm v√† T√¨m ƒë∆∞·ªùng</h3>

    <!-- T√¨m ki·∫øm ƒë·ªãa ch·ªâ -->
    <div>
      <input
        v-model="searchAddress"
        type="text"
        placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ c·∫ßn t√¨m"
        @keyup.enter="searchLocation"
      />
      <button @click="searchLocation">T√¨m ki·∫øm</button>
    </div>

    <!-- N√∫t t√¨m ƒë∆∞·ªùng ƒë·∫øn ƒë·ªãa ƒëi·ªÉm ƒë√£ ch·ªçn -->
    <div v-if="selectedLocation">
      <button @click="getDirections">T√¨m ƒë∆∞·ªùng ƒë·∫øn {{ selectedLocation.address }}</button>
    </div>

    <div v-if="routeDistance">
    <p><strong>Kho·∫£ng c√°ch:</strong> {{ routeDistance.toFixed(2) }} km</p>
  </div>

   <!-- N√∫t hi·ªÉn th·ªã l·∫°i s·ªë km -->
   <button v-if="routeDistance" @click="showDistance = !showDistance">
    {{ showDistance ? "·∫®n kho·∫£ng c√°ch" : "Hi·ªán kho·∫£ng c√°ch" }}
  </button>

  <button v-if="locations.length > 0" @click="showDistanceList = !showDistanceList">
    {{ showDistanceList ? "·∫®n Data" : "Hi·ªán Data" }}
  </button>

  <!-- Ch·ªçn ph∆∞∆°ng ti·ªán -->
  <select v-model="selectedTransport" @change="getDirections">
    <option value="driving-car">√î t√¥</option>
    <option value="cycling-regular">Xe ƒë·∫°p</option>
    <option value="foot-walking">ƒêi b·ªô</option>
    <option value="driving-hgv">Xe t·∫£i</option>
    <option value="airplane">M√°y bay</option>
  </select>
    <!-- B·∫£n ƒë·ªì -->
    <GMapMap
      :center="mapCenter"
      :zoom="zoomLevel"
      style="height: 500px; width: 100%;"
    >

    
      <!-- Marker cho t·∫•t c·∫£ v·ªã tr√≠ t√¨m ki·∫øm ƒë∆∞·ª£c -->
      <GMapMarker
        v-for="(location, index) in resolvedLocations"
        :key="index"
        :position="location.coordinates"
        :label="location.address"
        @click="showInfo(index)"
        
      >
          <!-- Hi·ªÉn th·ªã th√¥ng tin khi b·∫•m v√†o marker -->
      <GMapInfoWindow
        v-if="selectedMarker === index"
        :options="{ maxWidth: 250 }"
        @closeclick="selectedMarker = null"
      >
        <div>
          <h4>{{ location.name }}</h4>
          <p>{{ location.details }}</p>

          <button @click="clickDataLocation(location)">üöó T√¨m ƒë∆∞·ªùng</button>
        </div>
      </GMapInfoWindow>
  </GMapMarker>


  <!-- Marker cho t·∫•t c·∫£ v·ªã tr√≠ t√¨m ki·∫øm ƒë∆∞·ª£c -->
   <div v-for="(location, index) in locations" :key="index">
      <GMapMarker
      v-if="location.status == 1"
        :position="location.coordinates"
        :label="location.address"
        @click="showInfo(index)"
        :icon="{
          url: marker1.url,
          scaledSize: { width: 40, height: 40 }
        }"
      >
          <!-- Hi·ªÉn th·ªã th√¥ng tin khi b·∫•m v√†o marker -->

           <GMapInfoWindow
                  v-if="selectedMarker === index && showDistanceList"
                  :options="{ maxWidth: 250 }"
                  @closeclick="selectedMarker = null"
                  >
                  <div>
                      <h4>{{ location.name }}</h4>
                      <p>{{ location.details }}</p>

                      <button @click="clickDataLocation(location)">üöó T√¨m ƒë∆∞·ªùng</button>
                  </div>
                  </GMapInfoWindow>
     
  </GMapMarker>
  <GMapMarker
      v-if="location.status == 2"
        :position="location.coordinates"
        :label="location.address"
        @click="showInfo(index)"
        :icon="{
          url: marker1.url,
          scaledSize: { width: 40, height: 40 }
        }"
      >
          <!-- Hi·ªÉn th·ªã th√¥ng tin khi b·∫•m v√†o marker -->

           <GMapInfoWindow
                  v-if="selectedMarker === index && showDistanceList"
                  :options="{ maxWidth: 250 }"
                  @closeclick="selectedMarker = null"
                  >
                  <div>
                      <h4>{{ location.name }}</h4>
                      <p>{{ location.details }}</p>

                      <button @click="clickDataLocation(location)">üöó T√¨m ƒë∆∞·ªùng</button>
                  </div>
                  </GMapInfoWindow>
     
  </GMapMarker>

  <GMapMarker
      v-if="location.status == 3"
        :position="location.coordinates"
        :label="location.address"
        @click="showInfo(index)"
        :icon="{
          url: marker1.url,
          scaledSize: { width: 40, height: 40 }
        }"
      >
          <!-- Hi·ªÉn th·ªã th√¥ng tin khi b·∫•m v√†o marker -->

           <GMapInfoWindow
                  v-if="selectedMarker === index && showDistanceList"
                  :options="{ maxWidth: 250 }"
                  @closeclick="selectedMarker = null"
                  >
                  <div>
                      <h4>{{ location.name }}</h4>
                      <p>{{ location.details }}</p>

                      <button @click="clickDataLocation(location)">üöó T√¨m ƒë∆∞·ªùng</button>
                  </div>
                  </GMapInfoWindow>
     
  </GMapMarker>
   </div>
  

      <!-- Marker cho v·ªã tr√≠ hi·ªán t·∫°i -->
      <GMapMarker
        :position="currentLocation"
        label="B·∫°n"
        :icon="{
          url: 'https://cdn-icons-png.flaticon.com/512/25/25694.png',
          scaledSize: { width: 40, height: 40 }
        }"
      />

      <!-- ƒê∆∞·ªùng ƒëi -->
      <GMapPolyline
        v-if="routePath.length > 0 && selectedTransport !== 'airplane'"
        :path="routePath"
        :options="{
          strokeColor: '#A52A2A', // M√†u ƒë∆∞·ªùng
          strokeOpacity: 1.0,
          strokeWeight: 5
        }"
      />

        <!-- Hi·ªÉn th·ªã s·ªë km tr√™n b·∫£n ƒë·ªì -->
    <GMapMarker
      v-if="routeDistance && showDistance"
      :position="midPoint"
      label="üìè"
       @click="showDistance = !showDistance"
    >
      <GMapInfoWindow>
        <div>
          <strong>Kho·∫£ng c√°ch:</strong> {{ routeDistance.toFixed(2) }} km
        </div>
      </GMapInfoWindow>
    </GMapMarker>

     <!-- N√∫t trong b·∫£n ƒë·ªì -->
     <div class="map-buttons">
      <button @click="searchLocation">üìç T√¨m v·ªã tr√≠</button>
      <button @click="getDirections">üöó T√¨m ƒë∆∞·ªùng</button>
    </div>
    </GMapMap>
  </div>
</template>

<script setup>
/* global google */
import { ref, onMounted, computed, onUnmounted } from "vue";
import axios from "axios";

// V·ªã tr√≠ trung t√¢m b·∫£n ƒë·ªì (H·ªì Ch√≠ Minh)
const mapCenter = ref({ lat: 10.762622, lng: 106.660172 });
const zoomLevel = ref(12);

// V·ªã tr√≠ hi·ªán t·∫°i c·ªßa ng∆∞·ªùi d√πng
const currentLocation = ref({ lat: 10.762622, lng: 106.660172 });

// Danh s√°ch ƒë·ªãa ch·ªâ v√† v·ªã tr√≠ ƒë√£ gi·∫£i m√£
const resolvedLocations = ref([]);
const searchAddress = ref("");
const selectedLocation = ref(null); // ƒê·ªãa ƒëi·ªÉm ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ t√¨m ƒë∆∞·ªùng ƒëi
const routePath = ref([]);
const routeDistance = ref(null); // L∆∞u kho·∫£ng c√°ch qu√£ng ƒë∆∞·ªùng
// Kh√≥a API c·ªßa OpenRouteService
const apiKey = "5b3ce3597851110001cf6248bd48b134d5f8443fb2a538a1554ee87e";
const showDistance = ref(true);
const showDistanceList = ref(true);

// Danh s√°ch ƒë·ªãa ƒëi·ªÉm v·ªõi th√¥ng tin chi ti·∫øt
const locations = ref([
{
  name: "H√† N·ªôi",
  details: "Th·ªß ƒë√¥ c·ªßa Vi·ªát Nam.",
  coordinates: { lat: 21.0285, lng: 105.8542 },
  status: 2,
  address: "H√† N·ªôi"
},
{
  name: "ƒê√† N·∫µng",
  details: "Th√†nh ph·ªë bi·ªÉn ƒë·∫πp v·ªõi nhi·ªÅu c√¢y c·∫ßu n·ªïi ti·∫øng.",
  coordinates: { lat: 16.0471, lng: 108.2062 },
  status: 1,
  address: "ƒê√† N·∫µng"
},
{
  name: "H·ªì Ch√≠ Minh",
  details: "Th√†nh ph·ªë s√¥i ƒë·ªông nh·∫•t Vi·ªát Nam.",
  coordinates: { lat: 10.7769, lng: 106.7009 },
  status: 1,
  address: "H·ªì Ch√≠ Minh"
},

{
  name: "luzhu",
  details: "Th√†nh ph·ªë s√¥i ƒë·ªông nh·∫•t Vi·ªát Nam.",
  coordinates: { lat: 25.04794556996055, lng: 121.30918812901263 },
  status: 3,
  address: "luzhu"
},
]);

// L∆∞u marker ƒëang ƒë∆∞·ª£c ch·ªçn
const selectedMarker = ref(null);

const selectedTransport = ref("driving-car");

const intervalId = ref(null)
// Danh s√°ch ·∫£nh
const images = ref([
"https://png.pngtree.com/png-clipart/20230417/original/pngtree-return-of-investment-flat-icon-png-image_9064391.png",
"https://tse1.mm.bing.net/th?id=OIP.hJVb5niyA8--b88zKGj5zwHaHa&pid=Api&P=0&h=220",
"https://tse4.mm.bing.net/th?id=OIP.cdbGAINaMlm8uBalZf3QgAHaHa&pid=Api&P=0&h=220",
"https://png.pngtree.com/png-clipart/20230508/original/pngtree-megaphone-icon-png-image_9150343.png",
"https://img.lovepik.com/free-png/20211108/lovepik-sunlight-png-image_400507026_wh1200.png",
"https://cdn-icons-png.flaticon.com/512/25/25694.png"
]);

const marker1 = ref({
  url: images.value[0],
  scaledSize: { width: 40, height: 40 }
});

// H√†m ƒë·ªïi ·∫£nh m·ªói gi√¢y
const startImageRotation = () => {
let index = 0;
intervalId.value = setInterval(() => {
  index = (index + 1) % images.value.length; // Chuy·ªÉn ·∫£nh ti·∫øp theo
  marker1.value.url = images.value[index];
}, 100);
};

// const midPoint = ref(null)
// C√¥ng th·ª©c t√≠nh kho·∫£ng c√°ch ƒë∆∞·ªùng chim bay (Haversine)
const haversineDistance = (lat1, lon1, lat2, lon2) => {
const R = 6371; // B√°n k√≠nh Tr√°i ƒê·∫•t (km)
const dLat = (lat2 - lat1) * (Math.PI / 180);
const dLon = (lon2 - lon1) * (Math.PI / 180);
const a =
  Math.sin(dLat / 2) * Math.sin(dLat / 2) +
  Math.cos(lat1 * (Math.PI / 180)) *
    Math.cos(lat2 * (Math.PI / 180)) *
    Math.sin(dLon / 2) *
    Math.sin(dLon / 2);
const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
return R * c;
};
// Khi click v√†o marker, hi·ªÉn th·ªã th√¥ng tin
const showInfo = (index) => {
selectedMarker.value = index;
};

const clickDataLocation = (location) => {
  selectedLocation.value = location
  getDirections()
}
// Chuy·ªÉn ƒë·ªãa ch·ªâ th√†nh t·ªça ƒë·ªô
const geocodeAddress = async (address) => {
  return new Promise((resolve, reject) => {
    const geocoder = new google.maps.Geocoder();
    geocoder.geocode({ address }, (results, status) => {
      if (status === "OK" && results.length > 0) {
        const location = results[0].geometry.location;
        resolve({ lat: location.lat(), lng: location.lng() });
      } else {
        console.error(`Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ: ${address}`);
        reject(status);
      }
    });
  });
};

// T√¨m ki·∫øm ƒë·ªãa ch·ªâ m·ªõi
const searchLocation = async () => {
  if (!searchAddress.value) {
    alert("Vui l√≤ng nh·∫≠p ƒë·ªãa ch·ªâ!");
    return;
  }

  try {
    const coordinates = await geocodeAddress(searchAddress.value);

    // Th√™m ƒë·ªãa ch·ªâ m·ªõi v√†o danh s√°ch
    resolvedLocations.value.push({
      address: searchAddress.value,
      coordinates,
    });

    // C·∫≠p nh·∫≠t b·∫£n ƒë·ªì
    mapCenter.value = coordinates;
    zoomLevel.value = 15;

    // X√≥a √¥ input
    searchAddress.value = "";
  } catch (error) {
    alert("Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ, vui l√≤ng th·ª≠ l·∫°i!");
  }
};

// T√¨m ƒë∆∞·ªùng ƒë·∫øn v·ªã tr√≠ ƒë√£ ch·ªçn
const getDirections = async () => {
  if (!selectedLocation.value) {
    alert("Vui l√≤ng ch·ªçn m·ªôt ƒë·ªãa ƒëi·ªÉm!");
    return;
  }

  const start = currentLocation.value; // B·∫Øt ƒë·∫ßu t·ª´ v·ªã tr√≠ hi·ªán t·∫°i
  const end = selectedLocation.value.coordinates; // ƒêi·ªÉm ƒë·∫øn ƒë√£ ch·ªçn

  if (selectedTransport.value === "airplane") {
  // T√≠nh kho·∫£ng c√°ch ƒë∆∞·ªùng bay
  const distanceKm = haversineDistance(start.lat, start.lng, end.lat, end.lng);
  routeDistance.value = distanceKm

  // midPoint.value = {
  //   lat: (start.lat + end.lat) / 2,
  //   lng: (start.lng + end.lng) / 2,
  // };
  return
  }
  const url = `https://api.openrouteservice.org/v2/directions/${selectedTransport.value}?api_key=${apiKey}&start=${start.lng},${start.lat}&end=${end.lng},${end.lat}`;

  try {
    const response = await axios.get(url);
    console.log("D·ªØ li·ªáu API tr·∫£ v·ªÅ:", response.data);
    if (response.data.features && response.data.features.length > 0) {
      const route = response.data.features[0];
       const coordinates  = response.data.features[0].geometry.coordinates.map(coord => ({
        lat: coord[1],
        lng: coord[0]
      }));

      routePath.value = coordinates
      // L·∫•y kho·∫£ng c√°ch (m√©t) v√† ƒë·ªïi sang km
    routeDistance.value = route.properties.segments[0].distance / 1000;

  //   const midIndex = Math.floor(coordinates.length / 2);
  //   midPoint.value = coordinates[midIndex];
    } else {
      console.error("Kh√¥ng t√¨m th·∫•y tuy·∫øn ƒë∆∞·ªùng n√†o!");
      routePath.value = []
      routeDistance.value = null
    }
  } catch (error) {
    console.error("L·ªói khi l·∫•y ƒë∆∞·ªùng ƒëi:", error);
    routePath.value = []
    routeDistance.value = null
  }
};

// L·∫•y v·ªã tr√≠ hi·ªán t·∫°i c·ªßa ng∆∞·ªùi d√πng
const getCurrentLocation = () => {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        currentLocation.value = {
          lat: position.coords.latitude,
          lng: position.coords.longitude,
        };
        mapCenter.value = currentLocation.value;
      },
      (error) => {
        console.error("L·ªói khi l·∫•y v·ªã tr√≠:", error);
      }
    );
  }
};

// T√≠nh ƒëi·ªÉm gi·ªØa tuy·∫øn ƒë∆∞·ªùng ƒë·ªÉ hi·ªÉn th·ªã s·ªë km
const midPoint = computed(() => {
if (!routePath.value.length) return null;

const midIndex = Math.floor(routePath.value.length / 2);
return routePath.value[midIndex];
});

onMounted(() => {
  getCurrentLocation(); // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i khi t·∫£i trang
  startImageRotation()
});

onUnmounted(() => {
  // clearInterval(intervalId.value)
  console.log("Hello World")
})
</script>


<style scoped>

/* CSS ƒë·ªÉ hi·ªÉn th·ªã 2 n√∫t tr√™n b·∫£n ƒë·ªì */
.map-buttons {
position: absolute;
top: 300px;
left: 10px;
z-index: 1000;
display: flex;
flex-direction: column;
}

.map-buttons button {
background-color: white;
border: 1px solid #ccc;
padding: 10px;
margin-bottom: 5px;
cursor: pointer;
font-weight: bold;
border-radius: 5px;
}

.map-buttons button:hover {
background-color: #f0f0f0;
}
</style>

